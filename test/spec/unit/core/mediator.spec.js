// Generated by CoffeeScript 1.12.2
(function() {
  "use strict";
  describe("Mediator", function() {
    beforeEach(module("app_mediator"));
    describe("publish method", function() {
      it("should have a pubSub service", function() {
        return inject(function(pubSub) {
          return expect(pubSub).toBeDefined();
        });
      });
      it("is an accessible function", function() {
        return inject(function(pubSub) {
          return (expect(typeof pubSub.publish)).toEqual("function");
        });
      });
      it("should publish to a message", function() {
        return inject(function(pubSub) {
          var foo;
          foo = {
            cb: function() {
              return 2;
            }
          };
          spyOn(foo, "cb");
          pubSub.subscribe({
            msg: "test message",
            listener: foo.cb,
            msgScope: ["test"]
          });
          pubSub.publish({
            msg: "test message",
            data: 12,
            msgScope: ["test"]
          });
          return expect(foo.cb).toHaveBeenCalledWith("test message", 12);
        });
      });
      it("calls the callback passed, if defined", function() {
        return inject(function(pubSub) {
          var foo;
          foo = {
            cb: function() {},
            name: "",
            cb2: function() {
              return 2;
            }
          };
          spyOn(foo, "cb");
          pubSub.subscribe({
            msg: "test message",
            listener: foo.cb2,
            scope: foo
          });
          pubSub.publish({
            msg: "test message",
            data: 12,
            callback: function(err) {
              if (err != null) {
                console.log(err.message);
              }
              return foo.cb();
            }
          });
          return expect(foo.cb).toHaveBeenCalled();
        });
      });
      it("returns false if there is no matching msg in the mediator msg list", function() {
        return inject(function(pubSub) {
          return pubSub.publish({
            msg: "test message",
            listener: function(err) {
              return (expect(err != null)).toBe(false);
            },
            msgScope: ["test"]
          });
        });
      });
      it("calls the callback even if there are no subscribers", function() {
        return inject(function(pubSub) {
          var result;
          result = pubSub.publish({
            msg: "test message",
            callback: function(err) {
              return (expect(err != null)).toBe(false);
            },
            msgScope: ["test"]
          });
          return expect(result).toBe(false);
        });
      });
      it("publishes message only to scopes mentioned in the msgScope passed with publish call", function() {
        return inject(function(pubSub) {
          var foo, result;
          foo = {
            cb1: function() {},
            cb2: function() {},
            cb3: function() {}
          };
          spyOn(foo, "cb1");
          spyOn(foo, "cb2");
          spyOn(foo, "cb3");
          pubSub.subscribe({
            msg: "test message",
            listener: foo.cb1,
            msgScope: ["core"]
          });
          pubSub.subscribe({
            msg: "test message",
            listener: foo.cb2,
            msgScope: ["module"]
          });
          pubSub.subscribe({
            msg: "test message",
            listener: foo.cb3,
            msgScope: ["app"]
          });
          result = pubSub.publish({
            msg: "test message",
            msgScope: ["core", "module"]
          });
          expect(foo.cb1).toHaveBeenCalled();
          expect(foo.cb2).toHaveBeenCalled();
          return expect(foo.cb3).not.toHaveBeenCalled();
        });
      });
      it("returns false if msg is not string", function() {
        return inject(function(pubSub) {
          var res;
          res = pubSub.subscribe({
            msg: "String!",
            msgScope: ['test'],
            listener: function() {
              return console.log("listener is getting executed!!");
            }
          });
          res = pubSub.publish({
            msg: ['not a string'],
            msgScope: ['test']
          });
          expect(res).toEqual(false);
          res = pubSub.publish({
            msg: 'String!',
            msgScope: ['test']
          });
          return expect(typeof res).toEqual('object');
        });
      });
      return it("throws error if msgScope is absent or not an Array", function() {
        return inject(function(pubSub) {
          var res;
          res = pubSub.subscribe({
            msg: "test message",
            msgScope: ['test'],
            listener: function() {
              return console.log("listener is getting executed!!");
            }
          });
          expect(function() {
            return pubSub.publish({
              msg: "test message"
            });
          }).toThrow(new Error("msgScope is not defined"));
          expect(function() {
            return pubSub.publish({
              msg: "test message",
              msgScope: null
            });
          }).toThrow(new Error("msgScope is not defined"));
          expect(function() {
            return pubSub.publish({
              msg: "test message",
              msgScope: 'string'
            });
          }).toThrow(new Error("msgScope is not an Array instance"));
          res = pubSub.publish({
            msg: 'test message',
            msgScope: ['test']
          });
          return expect(typeof res).toEqual('object');
        });
      });
    });
    describe("subscribe function", function() {
      it("is an accessible function", function() {
        return inject(function(pubSub) {
          console.log("TEST -- it is an accessible function");
          return (expect(typeof pubSub.subscribe)).toEqual("function");
        });
      });
      it("should return false when no msgScope is provided", function() {
        return inject(function(pubSub) {
          var res;
          res = pubSub.subscribe({
            msg: "test message",
            listener: function() {
              return console.log("listener is getting executed!!");
            }
          });
          return expect(res).toEqual(false);
        });
      });
      it("should subscribe to a message", function() {
        return inject(function(pubSub) {
          var obj;
          obj = pubSub.subscribe({
            msg: "test message",
            listener: function() {},
            msgScope: ["test"]
          });
          return expect(obj['test message']['test']).toEqual(0);
        });
      });
      it("returns false if callback is not a function", function() {
        return inject(function(pubSub) {
          var res;
          console.log("TEST -- it returns false if callback is not a function");
          res = pubSub.subscribe({
            msg: "test message",
            listener: 345,
            msgScope: ["test"]
          });
          return expect(res).toEqual(false);
        });
      });
      it("subscribes a function to several messages", function() {
        return inject(function(pubSub) {
          var obj;
          console.log("TEST -- it subscribes a function to several messages");
          obj = {
            cb1: function() {}
          };
          spyOn(obj, "cb1");
          pubSub.subscribe({
            msg: ["a", "b"],
            listener: obj.cb1,
            msgScope: ["test"]
          }).publish({
            msg: "b",
            data: "foo",
            msgScope: ["test"]
          });
          (expect(obj.cb1.calls.count())).toEqual(1);
          pubSub.publish({
            msg: "b",
            data: "bar",
            msgScope: ["test"]
          });
          return (expect(obj.cb1.calls.count())).toEqual(2);
        });
      });
      return it("subscribes several functions to several messages", function() {
        return inject(function(pubSub) {
          var obj;
          console.log("TEST -- it subscribes several functions to several messages");
          obj = {
            cb1: function() {},
            cb2: function() {}
          };
          spyOn(obj, "cb1");
          spyOn(obj, "cb2");
          pubSub.subscribe({
            msg: {
              "a": obj.cb1,
              "b": obj.cb2
            },
            msgScope: ["test"]
          });
          pubSub.publish({
            msg: "a",
            data: "foo",
            msgScope: ["test"]
          });
          (expect(obj.cb1.calls.count())).toEqual(1);
          (expect(obj.cb2.calls.count())).toEqual(0);
          pubSub.publish({
            msg: "b",
            data: "foo",
            msgScope: ["test"]
          });
          (expect(obj.cb1.calls.count())).toEqual(1);
          return (expect(obj.cb2.calls.count())).toEqual(1);
        });
      });
    });
    return describe("unsubscribe function", function() {
      var foo;
      foo = {
        cb: function() {
          return 2;
        }
      };
      it("removes a listener from the specified message", function() {
        return inject(function(pubSub) {
          var token;
          console.log("TEST -- it should unsubscribe from a message");
          spyOn(foo, "cb");
          token = pubSub.subscribe({
            msg: "test message",
            msgScope: ['test'],
            listener: foo.cb
          });
          pubSub.publish({
            msg: "test message",
            msgScope: ['test']
          });
          expect(foo.cb).toHaveBeenCalled();
          expect(pubSub.unsubscribe(token)).toEqual(true);
          pubSub.publish({
            msg: "test message",
            msgScope: ['test']
          });
          return (expect(foo.cb.calls.count())).toEqual(1);
        });
      });
      return it("returns false when incorrect msg is passed", function() {
        return inject(function(pubSub) {
          var token;
          console.log("TEST -- returns false when incorrect msg is passed");
          token = pubSub.subscribe({
            msg: "test message",
            msgScope: ['test'],
            listener: function() {
              return 2;
            }
          });
          token = {
            'message with no listeners': {
              'test': 0
            }
          };
          return expect(pubSub.unsubscribe(token)).toEqual(false);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=mediator.spec.js.map
