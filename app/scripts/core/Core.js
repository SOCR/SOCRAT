// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var Core,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    hasProp = {}.hasOwnProperty;

  require('scripts/core/EventMngr.coffee');

  require('scripts/core/errorMngr.coffee');

  require('scripts/core/Sandbox.coffee');

  require('scripts/core/utils.coffee');


  /*
   * @name Core
   * @desc Class for registering and starting modules
   */

  module.exports = Core = (function() {
    Core.modules = {};

    Core.instances = {};

    Core.instanceOpts = {};

    Core.BaseModuleInitService = require('scripts/BaseClasses/BaseModuleInitService.coffee');

    function Core(eventMngr, Sandbox, utils1) {
      this.eventMngr = eventMngr;
      this.Sandbox = Sandbox;
      this.utils = utils1;
    }

    Core.prototype.checkType = function(type, val, name) {
      if (typeof val !== type && this.utils.typeIsArray(val) !== true) {
        console.log('%cCORE: checkType: ' + (name + " is not a " + type), 'color:red');
        throw new TypeError(name + " has to be a " + type);
      }
    };

    Core.getInstanceOptions = function(instanceId, module, opt) {
      var io, key, o, ref, val;
      o = {};
      ref = module.options;
      for (key in ref) {
        val = ref[key];
        o[key] = val;
      }
      io = Core.instanceOpts[instanceId];
      if (io) {
        for (key in io) {
          val = io[key];
          o[key] = val;
        }
      }
      if (opt) {
        for (key in opt) {
          val = opt[key];
          o[key] = val;
        }
      }
      return o;
    };

    Core.createInstance = function(moduleId, instanceId, opt) {
      var iOpts, instance, module, sb;
      if (instanceId == null) {
        instanceId = moduleId;
      }
      module = this.constructor.modules[moduleId];
      if (this.constructor.instances[instanceId] != null) {
        return this.constructor.instances[instanceId];
      }
      iOpts = this.constructor.getInstanceOptions.apply(this, [instanceId, module, opt]);
      sb = new this.Sandbox(instanceId, iOpts);
      this.utils.installFromTo(this.eventMngr.getInterface(), sb);
      if (module.moduleObj.init(sb)) {
        instance = module.moduleObj;
        instance.options = iOpts;
        instance.id = instanceId;
        this.constructor.instances[instanceId] = instance;
        console.log('%cCORE: created instance of ' + instance.id, 'color:red');
        return instance;
      } else {
        throw new TypeError("cannot init " + moduleId + ": msgService is not defined");
      }
    };

    Core.prototype.addModule = function(moduleId, moduleObj, opt) {
      var moduleMsgList;
      this.checkType('string', moduleId, 'module ID');
      this.checkType('object', opt, 'option parameter');
      if (moduleObj instanceof this.constructor.BaseModuleInitService) {
        this.checkType('function', moduleObj.init, '"init" of the module');
        this.checkType('function', moduleObj.destroy, '"destroy" of the module');
        this.checkType('function', moduleObj.getMsgList, '"getMsgList" of the module');
        moduleMsgList = moduleObj.getMsgList();
        this.checkType('object', moduleMsgList, 'message list of the module');
        this.checkType('object', moduleMsgList.outgoing, 'outcoming message list of the module');
        if (this.constructor.modules[moduleId] != null) {
          throw new TypeError("module " + moduleId + " was already registered");
        }
        this.constructor.modules[moduleId] = {
          moduleObj: moduleObj,
          options: opt,
          id: moduleId
        };
        console.log('%cCORE: module added: ' + moduleId, 'color:red');
        return true;
      } else {
        throw new TypeError("module " + moduleId + "'s init service is invalid");
        return false;
      }
    };

    Core.prototype.register = function(moduleId, creator, opt) {
      var e;
      if (opt == null) {
        opt = {};
      }
      try {
        return this.addModule.apply(this, [moduleId, creator, opt]);
      } catch (error) {
        e = error;
        console.log("%cCORE: could not register module " + moduleId, 'color:red');
        console.error("could not register module " + moduleId + ": " + e.message);
        return false;
      }
    };

    Core.unregister = function(id, type) {
      if (type[id] != null) {
        delete type[id];
        return true;
      }
      return false;
    };

    Core.unregisterAll = function(type) {
      var id, results;
      results = [];
      for (id in type) {
        results.push(this.unregister(id, type));
      }
      return results;
    };

    Core.setInstanceOptions = function(instanceId, opt) {
      var base, k, results, v;
      this.checkType('string', instanceId, 'instance ID');
      this.checkType('object', opt, 'option parameter');
      if ((base = this.instanceOpts)[instanceId] == null) {
        base[instanceId] = {};
      }
      results = [];
      for (k in opt) {
        v = opt[k];
        results.push(this.instanceOpts[instanceId][k] = v);
      }
      return results;
    };

    Core.prototype.start = function(moduleId, opt) {
      var e, instance;
      if (opt == null) {
        opt = {};
      }
      try {
        this.checkType('string', moduleId, 'module ID');
        this.checkType('object', opt, 'second parameter');
        if (this.constructor.modules[moduleId] == null) {
          throw new Error("module doesn't exist: " + moduleId);
        }
        instance = this.constructor.createInstance.apply(this, [moduleId, opt.instanceId, opt.options]);
        if (instance.running === true) {
          throw new Error('module was already started');
        }
        if ((instance.msgList != null) && (instance.msgList.outgoing != null) && indexOf.call(instance.msgList.scope, moduleId) >= 0) {
          console.log('%cCORE: subscribing for messages from ' + moduleId, 'color:red');
          this.eventMngr.subscribeForEvents({
            msgList: instance.msgList.outgoing,
            scope: [moduleId]
          }, this.eventMngr.redirectMsg);
        }
        instance.running = true;
        console.log('%cCORE: started module ' + moduleId, 'color:red');
        return true;
      } catch (error) {
        e = error;
        console.log("%cCORE: could not start module: " + e.message, 'color:red');
        if (typeof opt.callback === "function") {
          opt.callback(new Error("could not start module: " + e.message));
        }
        return false;
      }
    };

    Core.startAll = function(cb, opt) {
      var id, invalid, invalidErr, mods, ref, startAction, valid;
      if (cb instanceof Array) {
        mods = cb;
        cb = opt;
        opt = null;
        valid = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = mods.length; j < len; j++) {
            id = mods[j];
            if (this.modules[id] != null) {
              results.push(id);
            }
          }
          return results;
        }).call(this);
      } else {
        mods = valid = (function() {
          var results;
          results = [];
          for (id in this.modules) {
            results.push(id);
          }
          return results;
        }).call(this);
      }
      if ((valid.length === (ref = mods.length) && ref === 0)) {
        if (typeof cb === "function") {
          cb(null);
        }
        return true;
      } else if (valid.length !== mods.length) {
        invalid = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = mods.length; j < len; j++) {
            id = mods[j];
            if (!(indexOf.call(valid, id) >= 0)) {
              results.push("'" + id + "'");
            }
          }
          return results;
        })();
        invalidErr = new Error("these modules don't exist: " + invalid);
      }
      startAction = function(m, next) {
        var k, modOpts, o, v;
        o = {};
        modOpts = this.modules[m].options;
        for (k in modOpts) {
          if (!hasProp.call(modOpts, k)) continue;
          v = modOpts[k];
          if (v) {
            o[k] = v;
          }
        }
        o.callback = function(err) {
          if (typeof modOpts.callback === "function") {
            modOpts.callback(err);
          }
          return next(err);
        };
        return this.start(m, o);
      };
      utils.doForAll(valid, startAction, function(err) {
        var e, i, x;
        if ((err != null ? err.length : void 0) > 0) {
          e = new Error("errors occoured in the following modules: " + ("" + ((function() {
            var j, len, results;
            results = [];
            for (i = j = 0, len = err.length; j < len; i = ++j) {
              x = err[i];
              if (x != null) {
                results.push("'" + valid[i] + "'");
              }
            }
            return results;
          })())));
        }
        return typeof cb === "function" ? cb(e || invalidErr) : void 0;
      }, true);
      return invalidErr == null;
    };

    Core.stop = function(id, cb) {
      var instance;
      if (instance = this.instances[id]) {
        if ((utils.getArgumentNames(instance.destroy)).length >= 1) {
          instance.destroy(function(err) {
            return typeof cb === "function" ? cb(err) : void 0;
          });
        } else {
          instance.destroy();
          if (typeof cb === "function") {
            cb(null);
          }
        }
        delete this.instances[id];
        return true;
      } else {
        return false;
      }
    };

    Core.stopAll = function(cb) {
      var id;
      return utils.doForAll((function() {
        var results;
        results = [];
        for (id in this.instances) {
          results.push(id);
        }
        return results;
      }).call(this), ((function(_this) {
        return function() {
          return _this.stop.apply(_this, arguments);
        };
      })(this)), cb);
    };

    Core.ls = function(o) {
      var id, m, results;
      results = [];
      for (id in o) {
        m = o[id];
        results.push(id);
      }
      return results;
    };

    Core.prototype.setEventsMapping = function(msgMap) {
      this.checkType('object', msgMap, 'event map object');
      this.checkType('function', msgMap.getMap, 'event map getter');
      this.eventMngr.setMsgMap(msgMap.getMap());
      return true;
    };

    return Core;

  })();

  Core.$inject = ['eventMngr', 'Sandbox', 'utils'];

  angular.module('app_core', ['app_eventMngr', 'app_sandbox', 'app_utils']).service('app_core_service', Core);

}).call(this);

//# sourceMappingURL=Core.js.map
