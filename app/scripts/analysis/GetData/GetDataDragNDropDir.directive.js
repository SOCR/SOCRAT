// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var BaseDirective, GetDataDragNDropDir,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseDirective = require('scripts/BaseClasses/BaseDirective');


  /*
   * @name GetDataDragNDropDir
   * @desc Directive for drag-n-drop files into the handsontable
   * Inspired by http://buildinternet.com/2013/08/drag-and-drop-file-upload-with-angularjs/
   */

  module.exports = GetDataDragNDropDir = (function(superClass) {
    extend(GetDataDragNDropDir, superClass);

    function GetDataDragNDropDir() {
      return GetDataDragNDropDir.__super__.constructor.apply(this, arguments);
    }

    GetDataDragNDropDir.prototype.initialize = function() {
      this.restrict = 'A';
      return this.link = (function(_this) {
        return function(scope, element, attrs) {
          var checkSize, isTypeValid, processDragOverOrEnter, validMimeTypes;
          processDragOverOrEnter = function(event) {
            if (event != null) {
              event.preventDefault();
            }
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = 'copy';
            } else if (event.originalEvent.dataTransfer) {
              event.originalEvent.dataTransfer.effectAllowed = 'copy';
            }
            return false;
          };
          validMimeTypes = attrs.getdatadragndrop;
          checkSize = function(size) {
            var ref;
            if (((ref = attrs.maxFileSize) === (void 0) || ref === '') || (size / 1024) / 1024 < attrs.maxFileSize) {
              return true;
            } else {
              alert("File must be smaller than " + attrs.maxFileSize + " MB");
              return false;
            }
          };
          isTypeValid = function(type) {
            if ((validMimeTypes === (void 0) || validMimeTypes === '') || validMimeTypes.indexOf(type) > -1) {
              return true;
            } else {
              alert("Invalid file type.  File must be one of following types " + validMimeTypes);
              return false;
            }
          };
          element.bind('dragover', processDragOverOrEnter);
          element.bind('dragenter', processDragOverOrEnter);
          return element.bind('drop', function(event) {
            var file, name, reader, size, type;
            if (event != null) {
              event.preventDefault();
            }
            reader = new FileReader();
            reader.onload = function(evt) {
              if (checkSize(size) && isTypeValid(type)) {
                return scope.$apply(function() {
                  scope.mainArea.file = evt.target.result;
                  if (angular.isString(scope.mainArea.fileName)) {
                    return scope.mainArea.fileName = name;
                  }
                });
              }
            };
            file = event.dataTransfer ? event.dataTransfer.files[0] : event.originalEvent.dataTransfer.files[0];
            name = file.name;
            type = file.type;
            size = file.size;
            reader.readAsText(file, 'UTF-8');
            return false;
          });
        };
      })(this);
    };

    return GetDataDragNDropDir;

  })(BaseDirective);

}).call(this);

//# sourceMappingURL=GetDataDragNDropDir.directive.js.map
