// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var BaseService, ChartsTilfordTree,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseService = require('scripts/BaseClasses/BaseService.coffee');

  module.exports = ChartsTilfordTree = (function(superClass) {
    extend(ChartsTilfordTree, superClass);

    function ChartsTilfordTree() {
      return ChartsTilfordTree.__super__.constructor.apply(this, arguments);
    }

    ChartsTilfordTree.prototype.initialize = function() {};

    ChartsTilfordTree.prototype.drawTilfordTree = function(InputData, container) {
      var _svg, click, collapse, data, diagonal, diameter, duration, height, i, root, tree, update, width;
      data = JSON.parse(JSON.stringify(InputData));
      diameter = 600;
      width = diameter;
      height = diameter;
      i = 0;
      duration = 350;
      root = data;
      root.x0 = height / 2;
      root.y0 = 0;
      container.selectAll('svg').remove();
      tree = d3.layout.tree().size([360, diameter / 2 - 10]).separation(function(a, b) {
        return (a.parent === b.parent ? 1 : 2) / a.depth;
      });
      diagonal = d3.svg.diagonal.radial().projection(function(d) {
        return [d.y, d.x / 180 * Math.PI];
      });
      _svg = container.append('svg').attr('width', width).attr('height', height).append('g').attr('transform', 'translate(' + diameter / 2 + ',' + diameter / 2 + ')');
      update = function(source) {
        var link, links, node, nodeEnter, nodeExit, nodeUpdate, nodes;
        nodes = tree.nodes(root);
        links = tree.links(nodes);
        nodes.forEach(function(d) {
          return d.y = d.depth * 80;
        });
        node = _svg.selectAll('g.node').data(nodes, function(d) {
          return d.id || (d.id = ++i);
        });
        nodeEnter = node.enter().append('g').attr('class', 'node').on('click', click).on('dblclick', function(d) {
          if (d.url) {
            return window.open(d.url);
          }
        });
        nodeEnter.append('circle').attr('r', 1e-6).style('fill', function(d) {
          if (d._children) {
            return 'lightstellblue';
          } else {
            return '#fff';
          }
        });
        nodeEnter.append('text').attr('x', 10).attr('dy', '.35em').attr('text-anchor', 'start').text(function(d) {
          return d.name;
        }).style('fill-opacity', 1e-6);
        nodeUpdate = node.transition().duration(duration).attr('transform', function(d) {
          return 'rotate(' + (d.x - 90) + ')translate(' + d.y + ')';
        });
        nodeUpdate.select('circle').attr('r', 4.5).style('fill', function(d) {
          if (d._children) {
            return 'lightsteelblue';
          } else {
            return '#fff';
          }
        });
        nodeUpdate.select('text').style('fill-opacity', 1).attr('transform', function(d) {
          if (d.x < 180) {
            return 'translate(0)';
          } else {
            return 'rotate(180)translate(-' + (d.name.length + 50) + ')';
          }
        });
        nodeExit = node.exit().transition().duration(duration).remove();
        nodeExit.select('circle').attr('r', 1e-6);
        nodeExit.select('text').style('fill-opacity', 1e-6);
        link = _svg.selectAll('path.link').data(links, function(d) {
          return d.target.id;
        });
        link.enter().insert('path', 'g').attr('class', 'link').attr('d', function(d) {
          var o;
          o = {
            x: source.x0,
            y: source.y0
          };
          return diagonal({
            source: o,
            target: o
          });
        });
        link.transition().duration(duration).attr('d', diagonal);
        link.exit().transition().duration(duration).attr('d', function(d) {
          var o;
          o = {
            x: source.x0,
            y: source.y0
          };
          return diagonal({
            source: o,
            target: o
          });
        }).remove();
        return nodes.forEach(function(d) {
          d.x0 = d.x;
          return d.y0 = d.y;
        });
      };
      click = function(d) {
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else {
          d.children = d._children;
          d._children = null;
        }
        return update(d);
      };
      collapse = function(d) {
        if (d.children) {
          d._children = d.children;
          d._children.forEach(collapse);
          return d.children = null;
        }
      };
      root.children.forEach(collapse);
      update(root);
      return d3.select(self.frameElement).style('height', height);
    };

    return ChartsTilfordTree;

  })(BaseService);

}).call(this);

//# sourceMappingURL=ChartsTilfordTree.service.js.map
