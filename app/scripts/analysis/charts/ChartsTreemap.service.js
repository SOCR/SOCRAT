// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var BaseService, ChartsTreemap,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseService = require('scripts/BaseClasses/BaseService.coffee');

  module.exports = ChartsTreemap = (function(superClass) {
    extend(ChartsTreemap, superClass);

    function ChartsTreemap() {
      return ChartsTreemap.__super__.constructor.apply(this, arguments);
    }

    ChartsTreemap.prototype.initialize = function() {};

    ChartsTreemap.prototype.drawTreemap = function(svg, width, height, container, data) {
      var maxDepth, plotTreemap, sliderBar, sliderValue;
      maxDepth = 5;
      sliderValue = 3;
      sliderBar = container.append('input').attr('id', 'slider').attr('type', 'range').attr('min', '1').attr('max', maxDepth).attr('step', '1').attr('value', '3');
      plotTreemap = function(sliderValue, maxDepth) {
        var color, depthRestriction, filteredData, findMaxDepth, leafNodes, node, treemap;
        color = d3.scale.category10();
        depthRestriction = sliderValue;
        treemap = d3.layout.treemap().size([width, height]).padding(4).sticky(true).value(function(d) {
          return d.size;
        });
        filteredData = treemap.nodes(data).filter(function(d) {
          return d.depth < depthRestriction;
        });
        leafNodes = treemap.nodes(data).filter(function(d) {
          return !d.children;
        });
        findMaxDepth = function(d) {
          var i, j, ref, tmpMaxDepth;
          tmpMaxDepth = 0;
          for (i = j = 0, ref = d.length - 1; j <= ref; i = j += 1) {
            if (d[i].depth > tmpMaxDepth) {
              tmpMaxDepth = d[i].depth;
            }
          }
          return tmpMaxDepth;
        };
        maxDepth = findMaxDepth(leafNodes) + 1;
        sliderBar.attr('max', maxDepth);
        node = svg.append('g').selectAll('g.node').data(filteredData).enter().append('g').attr('class', 'node').attr('transform', function(d) {
          return 'translate(' + d.x + ',' + d.y + ')';
        }).append('svg').attr('class', 'inner-node').attr('width', function(d) {
          return Math.max(0.01, d.dx - 1);
        }).attr('height', function(d) {
          return Math.max(0.01, d.dy - 1);
        }).on('click', function(d) {
          if (d.url) {
            return window.open(d.url);
          }
        });
        node.append('rect').attr('width', function(d) {
          return Math.max(0.01, d.dx - 1);
        }).attr('height', function(d) {
          return Math.max(0.01, d.dy - 1);
        }).style('fill', function(d) {
          if (d.children) {
            return color(d.name);
          } else {
            return color(d.parent.name);
          }
        }).style('stroke', 'white').style('stroke-width', '1px').on('mouseover', function() {
          d3.select(this).append('title').text(function(d) {
            return 'Parent: ' + d.parent.name + '\n' + 'Name: ' + d.name + '\n' + 'Depth: ' + d.depth;
          });
          return d3.select(this).style('stroke', 'black').style('stroke-width', '3px');
        }).on('mouseout', function() {
          d3.select(this).style('stroke', 'white').style('stroke-width', '1px');
          return d3.select(this).select('title').remove();
        });
        $('#sliderText').remove();
        return container.append('text').attr('id', 'sliderText').text('Treemap depth: ' + sliderValue).attr('position', 'relative').attr('left', '50px');
      };
      plotTreemap(sliderValue, maxDepth);
      return d3.select('#slider').on('change', function() {
        sliderValue = parseInt(this.value);
        return plotTreemap(sliderValue, maxDepth);
      });
    };

    return ChartsTreemap;

  })(BaseService);

}).call(this);

//# sourceMappingURL=ChartsTreemap.service.js.map
