// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var BaseService, ChartsNormalChart,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseService = require('scripts/BaseClasses/BaseService.coffee');

  module.exports = ChartsNormalChart = (function(superClass) {
    extend(ChartsNormalChart, superClass);

    function ChartsNormalChart() {
      return ChartsNormalChart.__super__.constructor.apply(this, arguments);
    }

    ChartsNormalChart.prototype.initialize = function() {
      return this.distanceFromMean = 5;
    };

    ChartsNormalChart.prototype.extract = function(data, variable) {
      var d, j, len, tmp;
      tmp = [];
      for (j = 0, len = data.length; j < len; j++) {
        d = data[j];
        tmp.push(+d[variable]);
      }
      return tmp;
    };

    ChartsNormalChart.prototype.getRightBound = function(middle, step) {
      return middle + step * this.distanceFromMean;
    };

    ChartsNormalChart.prototype.getLeftBound = function(middle, step) {
      return middle - step * this.distanceFromMean;
    };

    ChartsNormalChart.prototype.sort = function(values) {
      return values.sort(function(a, b) {
        return a - b;
      });
    };

    ChartsNormalChart.prototype.getVariance = function(values, mean) {
      var numberOfValues, temp;
      temp = 0;
      numberOfValues = values.length;
      while (numberOfValues--) {
        temp += Math.pow(values[numberOfValues] - mean, 2);
      }
      return temp / values.length;
    };

    ChartsNormalChart.prototype.getSum = function(values) {
      return values.reduce(function(previousValue, currentValue) {
        return previousValue + currentValue;
      });
    };

    ChartsNormalChart.prototype.getGaussianFunctionPoints = function(std, mean, variance, leftBound, rightBound) {
      var data, i, j, ref, ref1;
      data = [];
      for (i = j = ref = leftBound, ref1 = rightBound; j < ref1; i = j += 1) {
        data.push({
          x: i,
          y: (1 / (std * Math.sqrt(Math.PI * 2))) * Math.exp(-(Math.pow(i - mean, 2) / (2 * variance)))
        });
      }
      console.log(data);
      return data;
    };

    ChartsNormalChart.prototype.getMean = function(valueSum, numberOfOccurrences) {
      return valueSum / numberOfOccurrences;
    };

    ChartsNormalChart.prototype.getZ = function(x, mean, standardDerivation) {
      return (x - mean) / standardDerivation;
    };

    ChartsNormalChart.prototype.getWeightedValues = function(values) {
      var data, i, j, label, lengthValues, ref, weightedValues;
      weightedValues = {};
      data = [];
      lengthValues = values.length;
      for (i = j = 0, ref = lengthValues; j < ref; i = j += 1) {
        label = values[i].toString();
        if (weightedValues[label]) {
          weightedValues[label].weight++;
        } else {
          weightedValues[label] = {
            weight: 1,
            value: label
          };
          data.push(weightedValues[label]);
        }
      }
      return data;
    };

    ChartsNormalChart.prototype.getRandomNumber = function(min, max) {
      return Math.round((max - min) * Math.random() + min);
    };

    ChartsNormalChart.prototype.getRandomValueArray = function(data) {
      var i, j, length, ref, values;
      values = [];
      length = data.length;
      for (i = j = 1, ref = length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        values.push(data[Math.floor(Math.random() * data.length)]);
      }
      return values;
    };

    ChartsNormalChart.prototype.drawNormalCurve = function(data, width, height, _graph) {
      var bottomBound, gaussianCurveData, leftBound, lineGen, max, mean, min, padding, radiusCoef, rightBound, sample, standardDerivation, sum, toolTipElement, topBound, variance, xAxis, xScale, yAxis, yScale;
      toolTipElement = _graph.append('div').attr('class', 'tooltipGauss').attr('position', 'absolute').attr('width', 15).attr('height', 10);
      ({
        showToolTip: function(value, positionX, positionY) {
          toolTipElement.style('display', 'block');
          toolTipElement.style('top', positionY + 10 + "px");
          toolTipElement.style('left', positionX + 10 + "px");
          return toolTipElement.innerHTML = " Z = " + value;
        },
        hideToolTip: function() {
          toolTipElement.style('display', 'none');
          return toolTipElement.innerHTML = " ";
        }
      });
      console.log(this.extract(data, "x"));
      sample = this.sort(this.getRandomValueArray(this.extract(data, "x")));
      sum = this.getSum(sample);
      min = sample[0];
      max = sample[sample.length - 1];
      mean = this.getMean(sum, sample.length);
      variance = this.getVariance(sample, mean);
      standardDerivation = Math.sqrt(variance);
      rightBound = this.getRightBound(mean, standardDerivation);
      leftBound = this.getLeftBound(mean, standardDerivation);
      bottomBound = 0;
      topBound = 1 / (standardDerivation * Math.sqrt(Math.PI * 2));
      gaussianCurveData = this.getGaussianFunctionPoints(standardDerivation, mean, variance, leftBound, rightBound);
      radiusCoef = 5;
      padding = 50;
      xScale = d3.scale.linear().range([0, width]).domain([leftBound, rightBound]);
      yScale = d3.scale.linear().range([height - padding, 0]).domain([bottomBound, topBound]);
      xAxis = d3.svg.axis().ticks(20).scale(xScale);
      yAxis = d3.svg.axis().scale(yScale).ticks(10).tickPadding(0).orient("right");
      lineGen = d3.svg.line().x(function(d) {
        return xScale(d.x);
      }).y(function(d) {
        return yScale(d.y);
      }).interpolate("basis");
      _graph.append('svg:path').attr('d', lineGen(gaussianCurveData)).data([gaussianCurveData]).attr('stroke', 'black').attr('stroke-width', 2).on('mousemove', function(d) {
        return showToolTip(getZ(xScale.invert(d3.event.x), mean, standardDerivation).toLocaleString(), d3.event.x, d3.event.y);
      }).on('mouseout', function(d) {
        return hideToolTip();
      }).attr('fill', "aquamarine");
      _graph.append("svg:g").attr("class", "x axis").attr("transform", "translate(0," + (height - padding) + ")").call(xAxis);
      _graph.append("svg:g").attr("class", "y axis").attr("transform", "translate(" + (xScale(mean)) + ",0)").call(yAxis);
      _graph.selectAll('.x.axis path').style({
        'fill': 'none',
        'stroke': 'black',
        'shape-rendering': 'crispEdges',
        'stroke-width': '1px'
      });
      _graph.selectAll('.y.axis path').style({
        'fill': 'none',
        'stroke': 'black',
        'shape-rendering': 'crispEdges',
        'stroke-width': '1px'
      });
      _graph.append("svg:g").append("text").attr("x", width / 2 + width / 4).attr("y", 20).style("text-anchor", "middle").style("fill", "white");
      return _graph.selectAll('.x.axis text').attr('transform', function(d) {
        return 'translate(' + this.getBBox().height * -2 + ',' + this.getBBox().height + ')rotate(-40)';
      }).style('font-size', '16px');
    };

    return ChartsNormalChart;

  })(BaseService);

}).call(this);

//# sourceMappingURL=ChartsNormalChart.service.js.map
