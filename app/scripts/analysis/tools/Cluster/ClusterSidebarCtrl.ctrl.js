// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var BaseCtrl, ClusterSidebarCtrl,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  BaseCtrl = require('scripts/BaseClasses/BaseController.coffee');

  module.exports = ClusterSidebarCtrl = (function(superClass) {
    extend(ClusterSidebarCtrl, superClass);

    function ClusterSidebarCtrl() {
      return ClusterSidebarCtrl.__super__.constructor.apply(this, arguments);
    }

    ClusterSidebarCtrl.inject('app_analysis_cluster_dataService', 'app_analysis_cluster_msgService', 'app_analysis_cluster_algorithms', '$scope', '$timeout');

    ClusterSidebarCtrl.prototype.initialize = function() {
      this.dataService = this.app_analysis_cluster_dataService;
      this.msgService = this.app_analysis_cluster_msgService;
      this.algorithmsService = this.app_analysis_cluster_algorithms;
      this.algorithms = this.algorithmsService.getNames();
      this.DATA_TYPES = this.dataService.getDataTypes();
      this.useLabels = false;
      this.reportAccuracy = true;
      this.clusterRunning = false;
      this.ready = false;
      this.running = 'hidden';
      this.uniqueLabels = {
        labelCol: null,
        num: null
      };
      this.algParams = null;
      this.iterDelay = 750;
      this.dataFrame = null;
      this.dataType = null;
      this.cols = [];
      this.chosenCols = [];
      this.numericalCols = [];
      this.categoricalCols = [];
      this.xCol = null;
      this.yCol = null;
      this.labelCol = null;
      if (this.algorithms.length > 0) {
        this.selectedAlgorithm = this.algorithms[0];
        this.updateAlgControls();
      }
      this.dataService.getData().then((function(_this) {
        return function(obj) {
          if (obj.dataFrame && (obj.dataFrame.dataType != null) && obj.dataFrame.dataType === _this.DATA_TYPES.FLAT) {
            if (_this.dataType !== obj.dataFrame.dataType) {
              _this.dataType = obj.dataFrame.dataType;
              _this.msgService.broadcast('cluster:updateDataType', obj.dataFrame.dataType);
            }
            _this.dataFrame = obj.dataFrame;
            return _this.parseData(obj.dataFrame);
          } else {
            return console.log('NESTED DATASET');
          }
        };
      })(this));
      return this.$timeout(function() {
        return $('input[type=checkbox]').bootstrapSwitch();
      });
    };

    ClusterSidebarCtrl.prototype.updateAlgControls = function() {
      return this.algParams = this.algorithmsService.getParamsByName(this.selectedAlgorithm);
    };

    ClusterSidebarCtrl.prototype.updateDataPoints = function(data, means, labels) {
      var row, xCol, yCol;
      if (data == null) {
        data = null;
      }
      if (means == null) {
        means = null;
      }
      if (labels == null) {
        labels = null;
      }
      if (data) {
        if (this.labelCol) {
          this.uniqueLabels = {
            num: this.uniqueVals((function() {
              var j, len, ref, results;
              ref = data.data;
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                row = ref[j];
                results.push(data.header.indexOf(this.labelCol));
              }
              return results;
            }).call(this)),
            labelCol: this.labelCol
          };
        }
        xCol = data.header.indexOf(this.xCol);
        yCol = data.header.indexOf(this.yCol);
        data = (function() {
          var j, len, ref, results;
          ref = data.data;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            row = ref[j];
            results.push([row[xCol], row[yCol]]);
          }
          return results;
        })();
      }
      return this.msgService.broadcast('cluster:updateDataPoints', {
        dataPoints: data,
        means: means,
        labels: labels
      });
    };

    ClusterSidebarCtrl.prototype.updateSidebarControls = function(data) {
      var col, colData, idx, lastCol, maxK, minK, ref, ref1, row;
      this.cols = data.header;
      this.numericalCols = (function() {
        var j, len, ref, ref1, results;
        ref = this.cols;
        results = [];
        for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
          col = ref[idx];
          if ((ref1 = data.types[idx]) === 'integer' || ref1 === 'number') {
            results.push(col);
          }
        }
        return results;
      }).call(this);
      this.categoricalCols = (function() {
        var j, len, ref, ref1, results;
        ref = this.cols;
        results = [];
        for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
          col = ref[idx];
          if ((ref1 = data.types[idx]) === 'string' || ref1 === 'integer') {
            results.push(col);
          }
        }
        return results;
      }).call(this);
      if (this.algParams.k) {
        ref = this.algParams.k, minK = ref[0], maxK = ref[ref.length - 1];
        colData = d3.transpose(data.data);
        this.categoricalCols = this.categoricalCols.filter((function(_this) {
          return function(x, i) {
            return _this.uniqueVals(colData[_this.cols.indexOf(x)]).length < maxK;
          };
        })(this));
      }
      ref1 = this.numericalCols, this.xCol = ref1[0], this.yCol = ref1[1], lastCol = ref1[ref1.length - 1];
      this.clusterRunning = false;
      if (this.labelCol) {
        this.uniqueLabels = {
          num: this.uniqueVals((function() {
            var j, len, ref2, results;
            ref2 = data.data;
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              row = ref2[j];
              results.push(data.header.indexOf(this.labelCol));
            }
            return results;
          }).call(this)),
          labelCol: this.labelCol
        };
      }
      return this.$timeout((function(_this) {
        return function() {
          return _this.updateDataPoints(data);
        };
      })(this));
    };

    ClusterSidebarCtrl.prototype.uniqueVals = function(arr) {
      return arr.filter(function(x, i, a) {
        return i === a.indexOf(x);
      });
    };

    ClusterSidebarCtrl.prototype.detectK = function() {
      var detectedK;
      detectedK = this.detectKValue();
      return this.setDetectedKValue(detectedK);
    };

    ClusterSidebarCtrl.prototype.setDetectedKValue = function(detectedK) {
      if (detectedK.num <= 10) {
        this.uniqueLabels = detectedK;
        return this.k = detectedK.num;
      } else {
        return console.log('KMEANS: k is more than 10');
      }
    };

    ClusterSidebarCtrl.prototype.detectKValue = function() {
      var labelCol, labels, row, uniqueLabels;
      if (this.dataFrame && this.labelCol) {
        labelCol = this.dataFrame.header.indexOf(this.labelCol);
        labels = (function() {
          var j, len, ref, results;
          ref = this.dataFrame.data;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            row = ref[j];
            results.push(row[labelCol]);
          }
          return results;
        }).call(this);
        uniqueLabels = this.uniqueVals(labels);
        return uniqueLabels = {
          labelCol: this.labelCol,
          num: uniqueLabels.length
        };
      }
    };

    ClusterSidebarCtrl.prototype.prepareData = function() {
      var acc, chosenIdxs, data, labelColIdx, labels, obj, row, xCol, yCol;
      data = this.dataFrame;
      if (this.chosenCols.length > 1) {
        xCol = data.header.indexOf(this.xCol);
        yCol = data.header.indexOf(this.yCol);
        chosenIdxs = this.chosenCols.map(function(x) {
          return data.header.indexOf(x);
        });
        if (this.labelCol) {
          labelColIdx = data.header.indexOf(this.labelCol);
          labels = (function() {
            var j, len, ref, results;
            ref = data.data;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              row = ref[j];
              results.push(row[labelColIdx]);
            }
            return results;
          })();
        } else {
          labels = null;
        }
        data = (function() {
          var j, len, ref, results;
          ref = data.data;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            row = ref[j];
            results.push(row.filter(function(el, idx) {
              return indexOf.call(chosenIdxs, idx) >= 0;
            }));
          }
          return results;
        })();
        if (this.k === this.uniqueLabels.num && this.accuracyon) {
          acc = true;
        }
        return obj = {
          data: data,
          labels: labels,
          xCol: xCol,
          yCol: yCol,
          acc: acc
        };
      } else {
        return false;
      }
    };

    ClusterSidebarCtrl.prototype.parseData = function(data) {
      return this.dataService.inferDataTypes(data, (function(_this) {
        return function(resp) {
          if (resp && resp.dataFrame) {
            _this.updateSidebarControls(resp.dataFrame);
            _this.updateDataPoints(resp.dataFrame);
            return _this.ready = true;
          }
        };
      })(this));
    };

    ClusterSidebarCtrl.prototype.runClustering = function() {
      var clustData, res;
      clustData = this.prepareData();
      this.kmeanson = true;
      this.running = 'spinning';
      return res = this.algorithmsService.cluster(this.selectedAlgorithm, clustData, this.k, this.initMethod, this.distance, this.iterDelay, (function(_this) {
        return function(res) {
          var row, xyMeans;
          xyMeans = (function() {
            var j, len, ref, results;
            ref = res.centroids;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              row = ref[j];
              results.push([row.val[clustData.xCol], row.val[clustData.yCol]]);
            }
            return results;
          })();
          _this.updateDataPoints(null, xyMeans, res.labels);
          return _this.$timeout(function() {
            _this.kmeanson = false;
            return _this.running = 'hidden';
          });
        };
      })(this));
    };

    ClusterSidebarCtrl.prototype.stepClustering = function() {
      var clustData, res, row, xyMeans;
      clustData = this.prepareData();
      this.kmeanson = true;
      this.running = 'spinning';
      res = this.algorithmsService.clusterStep(this.selectedAlgorithm, clustData, this.k, this.initMethod, this.distance);
      xyMeans = (function() {
        var j, len, ref, results;
        ref = res.centroids;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          row = ref[j];
          results.push([row.val[clustData.xCol], row.val[clustData.yCol]]);
        }
        return results;
      })();
      this.updateDataPoints(null, xyMeans, res.labels);
      return this.$timeout((function(_this) {
        return function() {
          _this.kmeanson = false;
          return _this.running = 'hidden';
        };
      })(this));
    };

    ClusterSidebarCtrl.prototype.reset = function() {
      this.algorithmsService.reset(this.selectedAlgorithm);
      return this.updateDataPoints(this.dataFrame, null, null);
    };

    return ClusterSidebarCtrl;

  })(BaseCtrl);

}).call(this);

//# sourceMappingURL=ClusterSidebarCtrl.ctrl.js.map
