// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var BaseModuleDataService, ClusterAlgorithms,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  BaseModuleDataService = require('scripts/BaseClasses/BaseModuleDataService.coffee');

  module.exports = ClusterAlgorithms = (function(superClass) {
    extend(ClusterAlgorithms, superClass);

    function ClusterAlgorithms() {
      return ClusterAlgorithms.__super__.constructor.apply(this, arguments);
    }

    ClusterAlgorithms.inject('app_analysis_cluster_msgService', 'app_analysis_cluster_kMeans', 'app_analysis_cluster_spectral', '$interval');

    ClusterAlgorithms.prototype.initialize = function() {
      this.msgManager = this.app_analysis_cluster_msgService;
      this.kmeans = this.app_analysis_cluster_kMeans;
      this.spectral = this.app_analysis_cluster_spectral;
      return this.algorithms = [this.kmeans, this.spectral];
    };

    ClusterAlgorithms.prototype.getNames = function() {
      return this.algorithms.map(function(alg) {
        return alg.getName();
      });
    };

    ClusterAlgorithms.prototype.getParamsByName = function(algName) {
      var alg;
      return ((function() {
        var j, len, ref, results;
        ref = this.algorithms;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          alg = ref[j];
          if (algName === alg.getName()) {
            results.push(alg.getParams());
          }
        }
        return results;
      }).call(this)).shift();
    };

    ClusterAlgorithms.prototype.getDataTypes = function() {
      return this.msgService.getSupportedDataTypes();
    };

    ClusterAlgorithms.prototype.clusterStep = function(algName, data, k, init, distance) {
      var alg, res;
      return res = ((function() {
        var j, len, ref, results;
        ref = this.algorithms;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          alg = ref[j];
          if (algName === alg.getName()) {
            results.push(alg.step(data, k, init, distance));
          }
        }
        return results;
      }).call(this)).shift();
    };

    ClusterAlgorithms.prototype.reset = function(algName) {
      var alg;
      return ((function() {
        var j, len, ref, results;
        ref = this.algorithms;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          alg = ref[j];
          if (algName === alg.getName()) {
            results.push(alg.reset());
          }
        }
        return results;
      }).call(this)).shift();
    };

    ClusterAlgorithms.prototype.cluster = function(algName, data, k, init, distance, iterDelay, cb) {
      var interval, res;
      if (iterDelay == null) {
        iterDelay = 0;
      }
      if (cb == null) {
        cb = null;
      }
      res = this.clusterStep(algName, data, k, init, distance);
      if (cb != null) {
        cb(res);
      }
      return interval = this.$interval((function(_this) {
        return function() {
          if (!res.done) {
            res = _this.clusterStep(algName);
            if (cb != null) {
              return cb(res);
            }
          } else {
            return _this.$interval.cancel(interval);
          }
        };
      })(this), iterDelay);
    };

    ClusterAlgorithms.prototype.evaluateAccuracy = function(labels, trueLabels) {
      var acc, accs, accuracy, currentEstLabel, estLabelCounts, i, j, k, kEstLabels, kTrueLabelIdxs, label, len, mostFrequentEstLabelIdx, uniqueEstLabels, uniqueLabels, x;
      accuracy = {};
      uniqueLabels = function(trueLabels) {
        return trueLabels.filter(function(x, i, a) {
          return i === a.indexOf(x);
        });
      };
      uniqueEstLabels = function(labels) {
        return labels.filter(function(x, i, a) {
          return i === a.indexOf(x);
        });
      };
      for (j = 0, len = uniqueLabels.length; j < len; j++) {
        k = uniqueLabels[j];
        kTrueLabelIdxs = (function() {
          var l, len1, results;
          results = [];
          for (i = l = 0, len1 = trueLabels.length; l < len1; i = ++l) {
            x = trueLabels[i];
            if (x === k) {
              results.push(i);
            }
          }
          return results;
        })();
        kEstLabels = (function() {
          var l, len1, results;
          results = [];
          for (i = l = 0, len1 = labels.length; l < len1; i = ++l) {
            x = labels[i];
            if (indexOf.call(kTrueLabelIdxs, i) >= 0) {
              results.push(x);
            }
          }
          return results;
        })();
        estLabelCounts = uniqueEstLabels.map(function(uniqueEstLabel) {
          var counts;
          counts = kEstLabels.reduce(function(n, val) {
            return n + (val === uniqueEstLabel);
          }, 0);
          return counts;
        });
        mostFrequentEstLabelIdx = estLabelCounts.indexOf(Math.max.apply(null, estLabelCounts));
        currentEstLabel = uniqueEstLabels[mostFrequentEstLabelIdx];
        uniqueEstLabels.splice(mostFrequentEstLabelIdx, 1);
        accuracy[k] = estLabelCounts[mostFrequentEstLabelIdx] / kTrueLabelIdxs.length;
      }
      accs = (function() {
        var results;
        results = [];
        for (label in accuracy) {
          if (!hasProp.call(accuracy, label)) continue;
          acc = accuracy[label];
          results.push(acc);
        }
        return results;
      })();
      accuracy['average'] = accs.reduce(function(r, s) {
        return r + s;
      }) / accs.length;
      return accuracy;
    };

    return ClusterAlgorithms;

  })(BaseModuleDataService);

}).call(this);

//# sourceMappingURL=ClusterAlgorithms.service.js.map
