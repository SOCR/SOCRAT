// Generated by CoffeeScript 1.12.2
(function() {
  'use strict';
  var BaseModuleDataService, ReliabilityTests, jStat,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  jStat = require('jstat').jStat;

  BaseModuleDataService = require('scripts/BaseClasses/BaseModuleDataService.coffee');

  module.exports = ReliabilityTests = (function(superClass) {
    extend(ReliabilityTests, superClass);

    function ReliabilityTests() {
      this.kr20 = bind(this.kr20, this);
      this.splitHalfReliability = bind(this.splitHalfReliability, this);
      this.icc = bind(this.icc, this);
      this.cAlphaAndConfIntervals = bind(this.cAlphaAndConfIntervals, this);
      return ReliabilityTests.__super__.constructor.apply(this, arguments);
    }

    ReliabilityTests.prototype.initialize = function() {
      this.metrics = [
        {
          name: "Cronbach's Alpha",
          method: this.cAlphaAndConfIntervals
        }, {
          name: 'Intraclass correlation coefficient',
          method: this.icc
        }, {
          name: 'Split-Half Reliability coefficient',
          method: this.splitHalfReliability
        }, {
          name: 'Kuderâ€“Richardson Formula 20 (KR-20)',
          method: this.kr20
        }
      ];
      this.matrix = [];
      return this.gamma = null;
    };

    ReliabilityTests.prototype.getMetricNames = function() {
      return this.metrics.map(function(metric) {
        return metric.name;
      });
    };

    ReliabilityTests.prototype.calculateMetric = function(name, data, confLevel) {
      var metric, res;
      return res = ((function() {
        var len, m, ref, results;
        ref = this.metrics;
        results = [];
        for (m = 0, len = ref.length; m < len; m++) {
          metric = ref[m];
          if (name === metric.name) {
            results.push(metric.method(data, confLevel));
          }
        }
        return results;
      }).call(this)).shift();
    };

    ReliabilityTests.prototype.cAlphaAndConfIntervals = function(data, confLevel) {
      var cAlpha, cAplhaConfIntervals, matrix;
      matrix = jStat(data);
      this.matrix = jStat(jStat.map(matrix, Number));
      this.gamma = (1 - confLevel) * 2;
      cAlpha = this.cronbachAlpha(this.matrix);
      cAplhaConfIntervals = this.cronbachAlphaConfIntervals(cAlpha);
      return {
        cAlpha: cAlpha,
        confIntervals: {
          id: cAplhaConfIntervals.id,
          adf: cAplhaConfIntervals.adf,
          kf: cAplhaConfIntervals.kf,
          bootstrap: cAplhaConfIntervals.bootstrap,
          logit: cAplhaConfIntervals.logit
        }
      };
    };

    ReliabilityTests.prototype.cronbachAlpha = function(matrix) {
      var cAlpha, k, rowTotalsVar, sumColsVar;
      matrix = jStat(matrix);
      k = jStat.cols(matrix);
      sumColsVar = jStat.sum(matrix.variance());
      rowTotalsVar = jStat.variance(matrix.transpose().sum());
      return cAlpha = (k / (k - 1)) * (1 - sumColsVar / rowTotalsVar);
    };

    ReliabilityTests.prototype.cronbachAlphaConfIntervals = function(cAlpha) {
      return {
        id: this.cAplhaIdConfInterval(this.matrix, cAlpha, this.gamma),
        adf: this.cAplhaAdfConfInterval(this.matrix, cAlpha, this.gamma),
        kf: this.cAlphaKfConfInterval(this.matrix, cAlpha, this.gamma),
        bootstrap: this.cAlphaBootstrapConfInterval(this.matrix, cAlpha, this.gamma),
        logit: this.cAlphaLogitConfInterval(this.matrix, cAlpha, this.gamma)
      };
    };

    ReliabilityTests.prototype.covMatrix = function(matrix) {
      var a, col, colMeans, colMeansSquared, cov, i, j, k, l, len, len1, m, matrixSquared, n, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, row, u;
      if (matrix != null) {
        matrix = jStat(this.matrix);
        k = jStat.cols(matrix);
        r = jStat.rows(matrix);
        matrixSquared = jStat.create(k, function(i, j) {
          return 0;
        });
        ref = matrix.transpose();
        for (i = m = 0, len = ref.length; m < len; i = ++m) {
          row = ref[i];
          ref1 = matrix.transpose();
          for (j = n = 0, len1 = ref1.length; n < len1; j = ++n) {
            col = ref1[j];
            matrixSquared[i][j] = ((function() {
              var results;
              results = [];
              for (l in row) {
                a = row[l];
                results.push(a * col[l]);
              }
              return results;
            })()).reduce(function(t, s) {
              return t + s;
            });
          }
        }
        colMeans = matrix.mean();
        colMeansSquared = jStat.create(k, function(i, j) {
          return 0;
        });
        for (i = o = 0, ref2 = k - 1; 0 <= ref2 ? o <= ref2 : o >= ref2; i = 0 <= ref2 ? ++o : --o) {
          for (j = p = 0, ref3 = k - 1; 0 <= ref3 ? p <= ref3 : p >= ref3; j = 0 <= ref3 ? ++p : --p) {
            colMeansSquared[i][j] = colMeans[i] * colMeans[j] * r;
          }
        }
        cov = jStat.create(k, function(i, j) {
          return 0;
        });
        for (i = q = 0, ref4 = k - 1; 0 <= ref4 ? q <= ref4 : q >= ref4; i = 0 <= ref4 ? ++q : --q) {
          for (j = u = 0, ref5 = k - 1; 0 <= ref5 ? u <= ref5 : u >= ref5; j = 0 <= ref5 ? ++u : --u) {
            cov[i][j] = (matrixSquared[i][j] - colMeansSquared[i][j]) * (1 / (r - 1));
          }
        }
        return cov;
      } else {
        return false;
      }
    };

    ReliabilityTests.prototype.cAplhaAdfConfInterval = function(matrix, cAlpha, gamma) {
      var adfIntervalLeft, adfIntervalRight, colMeans, covDiagSum, covMatrix, covOffDiagSum, covSum, dwrtcov, dwrtvar, i, isub, j, jac, k, len, m, n, nnase, o, p, q, r, ref, ref1, ref2, ref3, row, trac, v, wcv, wcvSum;
      covMatrix = this.covMatrix(matrix);
      k = k = jStat.cols(matrix);
      r = jStat.rows(matrix);
      if (covMatrix) {
        covSum = 0;
        covDiagSum = 0;
        for (i = m = 0, len = covMatrix.length; m < len; i = ++m) {
          row = covMatrix[i];
          covSum += row.reduce(function(a, b) {
            return a + b;
          });
          covDiagSum += row[i];
        }
        covOffDiagSum = (covSum - covDiagSum) / 2;
        colMeans = jStat(matrix).mean();
        dwrtvar = -2 * (k / (k - 1)) * covOffDiagSum / (covSum * covSum);
        dwrtcov = (k / (k - 1)) * covOffDiagSum / (covSum * covSum);
        jac = jStat.create(k, function(i, j) {
          return dwrtcov;
        });
        for (j = n = 0, ref = k - 1; 0 <= ref ? n <= ref : n >= ref; j = 0 <= ref ? ++n : --n) {
          jac[j][j] = dwrtvar;
        }
        trac = 0;
        for (isub = o = 0, ref1 = r - 1; 0 <= ref1 ? o <= ref1 : o >= ref1; isub = 0 <= ref1 ? ++o : --o) {
          v = jStat(matrix).row(isub)[0].map(function(x, i) {
            return x - colMeans[i];
          });
          wcv = jStat.create(k, function(i, j) {
            return 0;
          });
          wcvSum = 0;
          for (i = p = 0, ref2 = k - 1; 0 <= ref2 ? p <= ref2 : p >= ref2; i = 0 <= ref2 ? ++p : --p) {
            for (j = q = 0, ref3 = k - 1; 0 <= ref3 ? q <= ref3 : q >= ref3; j = 0 <= ref3 ? ++q : --q) {
              wcv[i][j] = jac[i][j] * (v[i] * v[j] - covMatrix[i][j]);
              wcvSum = wcvSum + wcv[i][j];
            }
          }
          trac = trac + wcvSum * wcvSum;
        }
        nnase = Math.sqrt((1 / r) * (1 / (r - 1)) * trac);
        adfIntervalLeft = cAlpha - jStat.normal.inv(1 - gamma / 2, 0, 1) * nnase;
        adfIntervalRight = cAlpha + jStat.normal.inv(1 - gamma / 2, 0, 1) * nnase;
        return [Math.max(0, adfIntervalLeft), Math.min(1, adfIntervalRight)];
      } else {
        return false;
      }
    };

    ReliabilityTests.prototype.cAplhaIdConfInterval = function(matrix, cAlpha, gamma) {
      var idIntervalAbsDev, idIntervalLeft, idIntervalRight, k, omega, r, varCapAlphaCap;
      k = k = jStat.cols(matrix);
      r = jStat.rows(matrix);
      omega = 2 * (k - 1) * (1 - cAlpha) / k;
      varCapAlphaCap = (k * k * omega) / (r * (k - 1) * (k - 1));
      idIntervalAbsDev = jStat.normal.inv(1 - gamma / 2, 0, 1) * Math.sqrt(varCapAlphaCap);
      idIntervalLeft = cAlpha - idIntervalAbsDev;
      idIntervalRight = cAlpha + idIntervalAbsDev;
      return [Math.max(0, idIntervalLeft), Math.min(1, idIntervalRight)];
    };

    ReliabilityTests.prototype.cAlphaKfConfInterval = function(matrix, cAlpha, gamma) {
      var k, kfIntervalLeft, kfIntervalRight, r;
      k = jStat.cols(matrix);
      r = jStat.rows(matrix);
      kfIntervalLeft = 1 - (1 - cAlpha) * Math.exp(jStat.normal.inv(1 - gamma / 2, 0, 1) * Math.sqrt(2 * k / (r * (k - 1))));
      kfIntervalRight = 1 - (1 - cAlpha) * Math.exp(-1 * jStat.normal.inv(1 - gamma / 2, 0, 1) * Math.sqrt(2 * k / (r * (k - 1))));
      return [Math.max(0, kfIntervalLeft), Math.min(1, kfIntervalRight)];
    };

    ReliabilityTests.prototype.cAlphaBootstrapConfInterval = function(matrix, cAlpha, gamma) {
      var B, accelAlphaDenom, accelAlphaNum, accelerationAlpha, alphaBootstrapped, alphaCapIthDeleted, alphaCapJackknife, bootstrapPercentiles, gamma1, gamma1Denom, gamma1Num, gamma2, gamma2Denom, gamma2Num, idx, k, m, matrixWithoutIdxRow, n, newRowIdx, o, r, ref, ref1, ref2, rowsAfterIdx, rowsBeforeIdx, sample, sampleMatrix, smallerAlphas, val, zCapZero;
      k = k = jStat.cols(matrix);
      r = jStat.rows(matrix);
      alphaCapIthDeleted = [];
      for (idx = m = 0, ref = r - 1; 0 <= ref ? m <= ref : m >= ref; idx = 0 <= ref ? ++m : --m) {
        rowsBeforeIdx = matrix.slice(0, idx);
        rowsAfterIdx = matrix.slice(idx + 1);
        matrixWithoutIdxRow = rowsBeforeIdx.concat(rowsAfterIdx);
        alphaCapIthDeleted.push(this.cronbachAlpha(matrixWithoutIdxRow));
      }
      alphaCapJackknife = (alphaCapIthDeleted.reduce(function(t, s) {
        return t + s;
      })) / r;
      accelAlphaNum = (alphaCapIthDeleted.map(function(x) {
        return x - alphaCapJackknife;
      })).map(function(x) {
        return Math.pow(x, 3);
      });
      accelAlphaNum = accelAlphaNum.reduce(function(t, s) {
        return t + s;
      });
      accelAlphaDenom = (alphaCapIthDeleted.map(function(x) {
        return x - alphaCapJackknife;
      })).map(function(x) {
        return Math.pow(x, 2);
      });
      accelAlphaDenom = 6 * Math.pow(accelAlphaDenom.reduce(function(t, s) {
        return t + s;
      }), 3 / 2);
      accelerationAlpha = accelAlphaNum / accelAlphaDenom;
      B = 1000;
      alphaBootstrapped = [];
      for (sample = n = 0, ref1 = B - 1; 0 <= ref1 ? n <= ref1 : n >= ref1; sample = 0 <= ref1 ? ++n : --n) {
        sampleMatrix = [];
        for (idx = o = 0, ref2 = r - 1; 0 <= ref2 ? o <= ref2 : o >= ref2; idx = 0 <= ref2 ? ++o : --o) {
          newRowIdx = Math.floor(Math.random() * r);
          sampleMatrix.push(matrix[newRowIdx]);
        }
        alphaBootstrapped.push(this.cronbachAlpha(sampleMatrix));
      }
      smallerAlphas = (function() {
        var len, p, results;
        results = [];
        for (p = 0, len = alphaBootstrapped.length; p < len; p++) {
          val = alphaBootstrapped[p];
          if (val < cAlpha) {
            results.push(val);
          }
        }
        return results;
      })();
      zCapZero = jStat.normal.inv(smallerAlphas.length / B, 0, 1);
      gamma1Num = zCapZero + jStat.normal.inv(gamma / 2, 0, 1);
      gamma1Denom = 1 - cAlpha * (zCapZero + jStat.normal.inv(gamma / 2, 0, 1));
      gamma1 = jStat.normal.cdf(zCapZero + gamma1Num / gamma1Denom, 0, 1);
      gamma2Num = zCapZero + jStat.normal.inv(1 - gamma / 2, 0, 1);
      gamma2Denom = 1 - cAlpha * (zCapZero + jStat.normal.inv(1 - gamma / 2, 0, 1));
      gamma2 = jStat.normal.cdf(zCapZero + gamma2Num / gamma2Denom, 0, 1);
      bootstrapPercentiles = [jStat.percentile(alphaBootstrapped, gamma1), jStat.percentile(alphaBootstrapped, gamma2)];
      bootstrapPercentiles = bootstrapPercentiles.sort();
      return [Math.max(0, bootstrapPercentiles[0]), Math.min(1, bootstrapPercentiles[1])];
    };

    ReliabilityTests.prototype.cAlphaLogitConfInterval = function(matrix, cAlpha, gamma) {
      var k, logitIntervalLeft, logitIntervalRight, omega, r, thetaAbsDev, thetaCap, thetaIntervalLeft, thetaIntervalRight, varCapAlphaCap, varCapThetaCap;
      k = jStat.cols(matrix);
      r = jStat.rows(matrix);
      omega = 2 * (k - 1) * (1 - cAlpha) / k;
      varCapAlphaCap = (k * k * omega) / (r * (k - 1) * (k - 1));
      thetaCap = Math.log(cAlpha / (1 - cAlpha));
      varCapThetaCap = varCapAlphaCap * Math.pow(1 / cAlpha + 1 / (1 - cAlpha), 2);
      thetaAbsDev = jStat.normal.inv(1 - gamma / 2, 0, 1) * Math.sqrt(varCapThetaCap);
      thetaIntervalLeft = thetaCap - thetaAbsDev;
      thetaIntervalRight = thetaCap + thetaAbsDev;
      logitIntervalLeft = Math.exp(thetaIntervalLeft) / (1 + Math.exp(thetaIntervalLeft));
      logitIntervalRight = Math.exp(thetaIntervalRight) / (1 + Math.exp(thetaIntervalRight));
      return [Math.max(0, logitIntervalLeft), Math.min(1, logitIntervalRight)];
    };

    ReliabilityTests.prototype.icc = function(matrix) {
      var colMeans, i, icc, ij, j, k, len, len1, m, matrixMean, msCols, msErr, msRows, n, r, row, rowMeans, ssCols, ssErr, ssRows;
      matrix = jStat(jStat.map(matrix, Number));
      k = jStat.cols(matrix);
      r = jStat.rows(matrix);
      matrixMean = jStat.sum(matrix.sum()) / (r * k);
      rowMeans = matrix.transpose().mean();
      colMeans = matrix.mean();
      ssRows = k * jStat.sum(jStat.pow(jStat.subtract(rowMeans, matrixMean), 2));
      ssCols = r * jStat.sum(jStat.pow(jStat.subtract(colMeans, matrixMean), 2));
      ssErr = 0;
      for (i = m = 0, len = matrix.length; m < len; i = ++m) {
        row = matrix[i];
        for (j = n = 0, len1 = row.length; n < len1; j = ++n) {
          ij = row[j];
          ssErr = ssErr + Math.pow(ij - rowMeans[i] - colMeans[j] + matrixMean, 2);
        }
      }
      msRows = ssRows / (r - 1);
      msCols = ssCols / (k - 1);
      msErr = ssErr / ((r - 1) * (k - 1));
      return icc = ((msRows - msErr) / k) / ((msRows - msErr) / k + (msCols - msErr) / r + msErr);
    };

    ReliabilityTests.prototype.splitHalfReliability = function(matrix) {
      var adjRCorrCoef, col, colIdx, evenSum, k, len, m, meanEven, meanOdd, n, nGroups, oddSum, r, rCorrCoef, ref, ref1, x;
      matrix = jStat(jStat.map(matrix, Number));
      k = jStat.cols(matrix);
      r = jStat.rows(matrix);
      nGroups = 2;
      oddSum = jStat.zeros(1, r)[0];
      evenSum = jStat.zeros(1, r)[0];
      ref = matrix.transpose();
      for (m = 0, len = ref.length; m < len; m += 2) {
        col = ref[m];
        evenSum = (function() {
          var results;
          results = [];
          for (x in evenSum) {
            results.push(evenSum[x] + col[x]);
          }
          return results;
        })();
      }
      for (colIdx = n = 1, ref1 = k - 1; n <= ref1; colIdx = n += 2) {
        col = jStat.transpose(jStat.col(matrix, colIdx));
        oddSum = (function() {
          var results;
          results = [];
          for (x in oddSum) {
            results.push(oddSum[x] + col[x]);
          }
          return results;
        })();
      }
      meanOdd = jStat.mean(oddSum);
      meanEven = jStat.mean(evenSum);
      rCorrCoef = jStat.corrcoeff(oddSum, evenSum);
      return adjRCorrCoef = rCorrCoef * nGroups / (1 + (nGroups - 1) * rCorrCoef);
    };

    ReliabilityTests.prototype.kr20 = function(matrix) {
      var kr20, zeroMatrix;
      matrix = jStat(jStat.map(matrix, Number));
      zeroMatrix = matrix.subtract(1);
      if (jStat.sum(jStat(zeroMatrix).sum()) !== 0) {
        return kr20 = 'Not a binary data';
      }
    };

    return ReliabilityTests;

  })(BaseModuleDataService);

}).call(this);

//# sourceMappingURL=ReliabilityTests.service.js.map
